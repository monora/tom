

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pandas.core.indexes.datetimes &mdash; Train Object Model 0.1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Train Object Model
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../readme.html">Extended Combined Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../domainmodel.html">Route Domain Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../routing-planning-process.html">Routing Planning Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_examples/index.html">ECM example trains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">tom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../history.html">History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Train Object Model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.indexes.datetimes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.indexes.datetimes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">tzinfo</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">NaT</span><span class="p">,</span> <span class="n">Period</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">index</span> <span class="k">as</span> <span class="n">libindex</span><span class="p">,</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Resolution</span><span class="p">,</span>
    <span class="n">ints_to_pydatetime</span><span class="p">,</span>
    <span class="n">parsing</span><span class="p">,</span>
    <span class="n">timezones</span><span class="p">,</span>
    <span class="n">to_offset</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs.offsets</span> <span class="kn">import</span> <span class="n">prefix_mapping</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="n">DtypeObj</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">InvalidIndexError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span><span class="p">,</span> <span class="n">doc</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DT64NS_DTYPE</span><span class="p">,</span>
    <span class="n">is_datetime64_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">is_valid_nat_for_dtype</span>

<span class="kn">from</span> <span class="nn">pandas.core.arrays.datetimes</span> <span class="kn">import</span> <span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">tz_to_dtype</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.base</span> <span class="kn">import</span> <span class="n">Index</span><span class="p">,</span> <span class="n">get_unanimous_names</span><span class="p">,</span> <span class="n">maybe_extract_name</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimelike</span> <span class="kn">import</span> <span class="n">DatetimeTimedeltaMixin</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.extension</span> <span class="kn">import</span> <span class="n">inherit_names</span>
<span class="kn">from</span> <span class="nn">pandas.core.tools.times</span> <span class="kn">import</span> <span class="n">to_time</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Float64Index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">,</span> <span class="n">TimedeltaIndex</span>


<span class="k">def</span> <span class="nf">_new_DatetimeIndex</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is called upon unpickling, rather than the default which doesn&#39;t</span>
<span class="sd">    have arguments and breaks __new__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;data&quot;</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
        <span class="c1"># Avoid need to verify integrity by calling simple_new directly</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DatetimeArray</span><span class="p">):</span>
            <span class="c1"># For backward compat with older pickles, we may need to construct</span>
            <span class="c1">#  a DatetimeArray to adapt to the newer _simple_new signature</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tz&quot;</span><span class="p">)</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
            <span class="n">dta</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dta</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">]:</span>
                <span class="c1"># These are already stored in our DatetimeArray; if they are</span>
                <span class="c1">#  also in the pickle and don&#39;t match, we have a problem.</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="c1"># TODO: If we knew what was going in to **d, we might be able to</span>
            <span class="c1">#  go through _simple_new instead</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="nd">@inherit_names</span><span class="p">(</span>
    <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_field_ops</span>
    <span class="o">+</span> <span class="p">[</span>
        <span class="n">method</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_datetimelike_methods</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;tz_localize&quot;</span><span class="p">,</span> <span class="s2">&quot;tz_convert&quot;</span><span class="p">)</span>
    <span class="p">],</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
    <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
<span class="nd">@inherit_names</span><span class="p">([</span><span class="s2">&quot;is_normalized&quot;</span><span class="p">,</span> <span class="s2">&quot;_resolution_obj&quot;</span><span class="p">],</span> <span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nd">@inherit_names</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="s2">&quot;_bool_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_object_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_field_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_datetimelike_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_datetimelike_methods&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tzinfo&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">,</span>
        <span class="s2">&quot;to_pydatetime&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_has_same_tz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_format_native_types&quot;</span><span class="p">,</span>
        <span class="s2">&quot;date&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;timetz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;std&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="o">+</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_bool_ops</span><span class="p">,</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">DatetimeIndex</span><span class="p">(</span><span class="n">DatetimeTimedeltaMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Immutable ndarray-like of datetime64 data.</span>

<span class="sd">    Represented internally as int64, and which can be boxed to Timestamp objects</span>
<span class="sd">    that are subclasses of datetime and carry metadata.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like (1-dimensional), optional</span>
<span class="sd">        Optional datetime-like data to construct index with.</span>
<span class="sd">    freq : str or pandas offset object, optional</span>
<span class="sd">        One of pandas date offset strings or corresponding objects. The string</span>
<span class="sd">        &#39;infer&#39; can be passed in order to set the frequency of the index as the</span>
<span class="sd">        inferred frequency upon creation.</span>
<span class="sd">    tz : pytz.timezone or dateutil.tz.tzfile or datetime.tzinfo or str</span>
<span class="sd">        Set the Timezone of the data.</span>
<span class="sd">    normalize : bool, default False</span>
<span class="sd">        Normalize start/end dates to midnight before generating date range.</span>
<span class="sd">    closed : {&#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">        Set whether to include `start` and `end` that are on the</span>
<span class="sd">        boundary. The default includes boundary points on either end.</span>
<span class="sd">    ambiguous : &#39;infer&#39;, bool-ndarray, &#39;NaT&#39;, default &#39;raise&#39;</span>
<span class="sd">        When clocks moved backward due to DST, ambiguous times may arise.</span>
<span class="sd">        For example in Central European Time (UTC+01), when going from 03:00</span>
<span class="sd">        DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC</span>
<span class="sd">        and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter</span>
<span class="sd">        dictates how ambiguous times should be handled.</span>

<span class="sd">        - &#39;infer&#39; will attempt to infer fall dst-transition hours based on</span>
<span class="sd">          order</span>
<span class="sd">        - bool-ndarray where True signifies a DST time, False signifies a</span>
<span class="sd">          non-DST time (note that this flag is only applicable for ambiguous</span>
<span class="sd">          times)</span>
<span class="sd">        - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">        - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous times.</span>
<span class="sd">    dayfirst : bool, default False</span>
<span class="sd">        If True, parse dates in `data` with the day first order.</span>
<span class="sd">    yearfirst : bool, default False</span>
<span class="sd">        If True parse dates in `data` with the year first order.</span>
<span class="sd">    dtype : numpy.dtype or DatetimeTZDtype or str, default None</span>
<span class="sd">        Note that the only NumPy dtype allowed is ‘datetime64[ns]’.</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">        Make a copy of input ndarray.</span>
<span class="sd">    name : label, default None</span>
<span class="sd">        Name to be stored in the index.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    year</span>
<span class="sd">    month</span>
<span class="sd">    day</span>
<span class="sd">    hour</span>
<span class="sd">    minute</span>
<span class="sd">    second</span>
<span class="sd">    microsecond</span>
<span class="sd">    nanosecond</span>
<span class="sd">    date</span>
<span class="sd">    time</span>
<span class="sd">    timetz</span>
<span class="sd">    dayofyear</span>
<span class="sd">    day_of_year</span>
<span class="sd">    weekofyear</span>
<span class="sd">    week</span>
<span class="sd">    dayofweek</span>
<span class="sd">    day_of_week</span>
<span class="sd">    weekday</span>
<span class="sd">    quarter</span>
<span class="sd">    tz</span>
<span class="sd">    freq</span>
<span class="sd">    freqstr</span>
<span class="sd">    is_month_start</span>
<span class="sd">    is_month_end</span>
<span class="sd">    is_quarter_start</span>
<span class="sd">    is_quarter_end</span>
<span class="sd">    is_year_start</span>
<span class="sd">    is_year_end</span>
<span class="sd">    is_leap_year</span>
<span class="sd">    inferred_freq</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    normalize</span>
<span class="sd">    strftime</span>
<span class="sd">    snap</span>
<span class="sd">    tz_convert</span>
<span class="sd">    tz_localize</span>
<span class="sd">    round</span>
<span class="sd">    floor</span>
<span class="sd">    ceil</span>
<span class="sd">    to_period</span>
<span class="sd">    to_perioddelta</span>
<span class="sd">    to_pydatetime</span>
<span class="sd">    to_series</span>
<span class="sd">    to_frame</span>
<span class="sd">    month_name</span>
<span class="sd">    day_name</span>
<span class="sd">    mean</span>
<span class="sd">    std</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Index : The base pandas Index type.</span>
<span class="sd">    TimedeltaIndex : Index of timedelta64 data.</span>
<span class="sd">    PeriodIndex : Index of Period data.</span>
<span class="sd">    to_datetime : Convert argument to datetime.</span>
<span class="sd">    date_range : Create a fixed-frequency DatetimeIndex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To learn more about the frequency strings, please see `this link</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_typ</span> <span class="o">=</span> <span class="s2">&quot;datetimeindex&quot;</span>

    <span class="n">_data_cls</span> <span class="o">=</span> <span class="n">DatetimeArray</span>
    <span class="n">_engine_type</span> <span class="o">=</span> <span class="n">libindex</span><span class="o">.</span><span class="n">DatetimeEngine</span>
    <span class="n">_supports_partial_string_indexing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_comparables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;freqstr&quot;</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">]</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">]</span>

    <span class="n">_is_numeric_dtype</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_data</span><span class="p">:</span> <span class="n">DatetimeArray</span>
    <span class="n">inferred_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tzinfo</span><span class="p">]</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># methods that dispatch to DatetimeArray and wrap result</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">strftime</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strftime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">date_format</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DatetimeIndex&quot;</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">tz_localize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="n">nonexistent</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DatetimeIndex&quot;</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">,</span> <span class="n">nonexistent</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">to_period</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PeriodIndex&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="n">PeriodIndex</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PeriodIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">to_perioddelta</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_perioddelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TimedeltaIndex&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="n">TimedeltaIndex</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">to_perioddelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimedeltaIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">to_julian_date</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_julian_date</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Float64Index&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="n">Float64Index</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">to_julian_date</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Float64Index</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">isocalendar</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isocalendar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">isocalendar</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ambiguous</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">yearfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() must be called with a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;collection of some kind, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> was passed&quot;</span>
            <span class="p">)</span>

        <span class="c1"># - Cases checked above all return/raise before reaching here - #</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">maybe_extract_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

        <span class="n">dtarr</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_from_sequence_not_strict</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
            <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
            <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">subarr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dtarr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subarr</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_is_dates_only</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean if we are only dates (and don&#39;t have a timezone)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">is_dates_only</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_dates_only</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># we use a special reduce here because we need</span>
        <span class="c1"># to simply set the .tz (and not reinterpret it)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">}</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">_new_DatetimeIndex</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">d</span><span class="p">),</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_validate_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert value to be insertable to ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_validate_setitem_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_comparable_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeObj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we compare values of the given dtype to our own?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If we have tz, we can compare to tzaware</span>
            <span class="k">return</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># if we dont have tz, we can only compare to tznaive</span>
        <span class="k">return</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">_mpl_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># how to represent ourselves to matplotlib</span>
        <span class="k">return</span> <span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_formatter_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">get_format_datetime64</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">get_format_datetime64</span><span class="p">(</span><span class="n">is_dates_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_dates_only</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Set Operation Methods</span>

    <span class="k">def</span> <span class="nf">union_many</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bit of a hack to accelerate unioning a collection of indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_maybe_utc_convert</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">this</span><span class="o">.</span><span class="n">_can_fast_union</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_fast_union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_unanimous_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">this</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">res_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">res_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">_maybe_utc_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;DatetimeIndex&quot;</span><span class="p">,</span> <span class="n">Index</span><span class="p">]:</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot join tz-naive with tz-aware DatetimeIndex&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot join tz-naive with tz-aware DatetimeIndex&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">tz_compare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">tz</span><span class="p">):</span>
                <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_get_time_micros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of microseconds since midnight.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray[int64_t]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>

        <span class="n">nanos</span> <span class="o">=</span> <span class="n">values</span> <span class="o">%</span> <span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">1_000_000_000</span><span class="p">)</span>
        <span class="n">micros</span> <span class="o">=</span> <span class="n">nanos</span> <span class="o">//</span> <span class="mi">1000</span>

        <span class="n">micros</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">micros</span>

    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_tz</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Series with both index and values equal to the index keys</span>
<span class="sd">        useful with map for returning an indexer based on an index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep_tz : optional, defaults True</span>
<span class="sd">            Return the data keeping the timezone.</span>

<span class="sd">            If keep_tz is True:</span>

<span class="sd">              If the timezone is not set, the resulting</span>
<span class="sd">              Series will have a datetime64[ns] dtype.</span>

<span class="sd">              Otherwise the Series will have an datetime64[ns, tz] dtype; the</span>
<span class="sd">              tz will be preserved.</span>

<span class="sd">            If keep_tz is False:</span>

<span class="sd">              Series will have a datetime64[ns] dtype. TZ aware</span>
<span class="sd">              objects will have the tz removed.</span>

<span class="sd">            .. versionchanged:: 1.0.0</span>
<span class="sd">                The default value is now True.  In a future version,</span>
<span class="sd">                this keyword will be removed entirely.  Stop passing the</span>
<span class="sd">                argument to obtain the future behavior and silence the warning.</span>

<span class="sd">        index : Index, optional</span>
<span class="sd">            Index of resulting Series. If None, defaults to original index.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name of resulting Series. If None, defaults to name of original</span>
<span class="sd">            index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">keep_tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keep_tz</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The &#39;keep_tz&#39; keyword in DatetimeIndex.to_series &quot;</span>
                    <span class="s2">&quot;is deprecated and will be removed in a future version.  &quot;</span>
                    <span class="s2">&quot;You can stop passing &#39;keep_tz&#39; to silence this warning.&quot;</span><span class="p">,</span>
                    <span class="ne">FutureWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Specifying &#39;keep_tz=False&#39; is deprecated and this &quot;</span>
                    <span class="s2">&quot;option will be removed in a future release. If &quot;</span>
                    <span class="s2">&quot;you want to remove the timezone information, you &quot;</span>
                    <span class="s2">&quot;can do &#39;idx.tz_convert(None)&#39; before calling &quot;</span>
                    <span class="s2">&quot;&#39;to_series&#39;.&quot;</span><span class="p">,</span>
                    <span class="ne">FutureWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep_tz</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">keep_tz</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># preserve the tz &amp; copy</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;M8[ns]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">snap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Snap time stamps to nearest occurring frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DatetimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Superdumb, punting on any optimizing</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">snapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DT64NS_DTYPE</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">freq</span><span class="o">.</span><span class="n">is_on_offset</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">t0</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">rollforward</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">s</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">t0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">t1</span>
            <span class="n">snapped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="n">dta</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="p">(</span><span class="n">snapped</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Indexing Methods</span>

    <span class="k">def</span> <span class="nf">_parsed_string_to_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reso</span><span class="p">:</span> <span class="n">Resolution</span><span class="p">,</span> <span class="n">parsed</span><span class="p">:</span> <span class="n">datetime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate datetime bounds for parsed time string and its resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reso : str</span>
<span class="sd">            Resolution provided by parsed string.</span>
<span class="sd">        parsed : datetime</span>
<span class="sd">            Datetime from parsed string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lower, upper: pd.Timestamp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">Resolution</span><span class="p">),</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">reso</span><span class="p">),</span> <span class="n">reso</span><span class="p">)</span>
        <span class="n">valid_resos</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;year&quot;</span><span class="p">,</span>
            <span class="s2">&quot;month&quot;</span><span class="p">,</span>
            <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;day&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hour&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
            <span class="s2">&quot;second&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
            <span class="s2">&quot;second&quot;</span><span class="p">,</span>
            <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">reso</span><span class="o">.</span><span class="n">attrname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_resos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>

        <span class="n">grp</span> <span class="o">=</span> <span class="n">reso</span><span class="o">.</span><span class="n">freq_group</span>
        <span class="n">per</span> <span class="o">=</span> <span class="n">Period</span><span class="p">(</span><span class="n">parsed</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">grp</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">per</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">per</span><span class="o">.</span><span class="n">end_time</span>

        <span class="c1"># GH 24076</span>
        <span class="c1"># If an incoming date string contained a UTC offset, need to localize</span>
        <span class="c1"># the parsed date to this offset first before aligning with the index&#39;s</span>
        <span class="c1"># timezone</span>
        <span class="k">if</span> <span class="n">parsed</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The index must be timezone aware when indexing &quot;</span>
                    <span class="s2">&quot;with a date string with a UTC offset&quot;</span>
                <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">)</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">)</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>

    <span class="k">def</span> <span class="nf">_validate_partial_date_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reso</span><span class="p">:</span> <span class="n">Resolution</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">Resolution</span><span class="p">),</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">reso</span><span class="p">),</span> <span class="n">reso</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span>
            <span class="ow">and</span> <span class="n">reso</span><span class="o">.</span><span class="n">attrname</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">,</span> <span class="s2">&quot;hour&quot;</span><span class="p">,</span> <span class="s2">&quot;minute&quot;</span><span class="p">,</span> <span class="s2">&quot;second&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolution_obj</span> <span class="o">&gt;=</span> <span class="n">reso</span>
        <span class="p">):</span>
            <span class="c1"># These resolution/monotonicity validations came from GH3931,</span>
            <span class="c1"># GH3452 and GH2369.</span>

            <span class="c1"># See also GH14826</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>

        <span class="k">if</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;microsecond&quot;</span><span class="p">:</span>
            <span class="c1"># _partial_date_slice doesn&#39;t allow microsecond resolution, but</span>
            <span class="c1"># _parsed_string_to_bounds allows it.</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>

    <span class="k">def</span> <span class="nf">_deprecate_mismatched_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># GH#36148</span>
        <span class="c1"># we get here with isinstance(key, self._data._recognized_scalars)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_assert_tzawareness_compat</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Indexing a timezone-naive DatetimeIndex with a &quot;</span>
                    <span class="s2">&quot;timezone-aware datetime is deprecated and will &quot;</span>
                    <span class="s2">&quot;raise KeyError in a future version.  &quot;</span>
                    <span class="s2">&quot;Use a timezone-naive object instead.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Indexing a timezone-aware DatetimeIndex with a &quot;</span>
                    <span class="s2">&quot;timezone-naive datetime is deprecated and will &quot;</span>
                    <span class="s2">&quot;raise KeyError in a future version.  &quot;</span>
                    <span class="s2">&quot;Use a timezone-aware object instead.&quot;</span>
                <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integer location for requested label</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loc : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">orig_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="n">is_valid_nat_for_dtype</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">NaT</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_recognized_scalars</span><span class="p">):</span>
            <span class="c1"># needed to localize naive datetimes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate_mismatched_indexing</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_for_get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_string_slice</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
                <span class="k">pass</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_for_get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">):</span>
            <span class="c1"># GH#20464</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot index </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot yet lookup inexact labels when key is a time object&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># unrecognized type</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">orig_key</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_for_get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Timestamp</span><span class="p">:</span>
        <span class="c1"># needed to localize naive datetimes or dates (GH 35690)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_slice_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If label is a string, cast it to datetime according to resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}</span>
<span class="sd">        kind : {&#39;loc&#39;, &#39;getitem&#39;} or None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        label : object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Value of `side` parameter should be validated in caller.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;getitem&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;freqstr&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;inferred_freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parsed</span><span class="p">,</span> <span class="n">reso</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">parse_time_string</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parsing</span><span class="o">.</span><span class="n">DateParseError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="n">reso</span> <span class="o">=</span> <span class="n">Resolution</span><span class="o">.</span><span class="n">from_attrname</span><span class="p">(</span><span class="n">reso</span><span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsed_string_to_bounds</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">parsed</span><span class="p">)</span>
            <span class="c1"># lower, upper form the half-open interval:</span>
            <span class="c1">#   [parsed, parsed + 1 freq)</span>
            <span class="c1"># because label may be passed to searchsorted</span>
            <span class="c1"># the bounds need swapped if index is reverse sorted and has a</span>
            <span class="c1"># length &gt; 1 (is_monotonic_decreasing gives True for empty</span>
            <span class="c1"># and length 1 index)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_strictly_monotonic_decreasing</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">upper</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="n">lower</span>
            <span class="k">return</span> <span class="n">lower</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="n">upper</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_recognized_scalars</span><span class="p">,</span> <span class="n">date</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate_mismatched_indexing</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_for_get_loc</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_string_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;freqstr&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;inferred_freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">parsed</span><span class="p">,</span> <span class="n">reso</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">parse_time_string</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
        <span class="n">reso</span> <span class="o">=</span> <span class="n">Resolution</span><span class="o">.</span><span class="n">from_attrname</span><span class="p">(</span><span class="n">reso</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_date_slice</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">parsed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return indexer for specified label slice.</span>
<span class="sd">        Index.slice_indexer, customized to handle time slicing.</span>

<span class="sd">        In addition to functionality provided by Index.slice_indexer, does the</span>
<span class="sd">        following:</span>

<span class="sd">        - if both `start` and `end` are instances of `datetime.time`, it</span>
<span class="sd">          invokes `indexer_between_time`</span>
<span class="sd">        - if `start` and `end` are both either string or None perform</span>
<span class="sd">          value-based selection in non-monotonic cases.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For historical reasons DatetimeIndex supports slices between two</span>
        <span class="c1"># instances of datetime.time as if it were applying a slice mask to</span>
        <span class="c1"># an array of (self.hour, self.minute, self.seconds, self.microsecond).</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have step size of 1 with time slices&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexer_between_time</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot mix time and non-time slice keys&quot;</span><span class="p">)</span>

        <span class="c1"># Pandas supports slicing with dates, treated as datetimes at midnight.</span>
        <span class="c1"># https://github.com/pandas-dev/pandas/issues/31501</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># For historical reasons DatetimeIndex by default supports</span>
            <span class="c1"># value-based partial (aka string) slices on non-monotonic arrays,</span>
            <span class="c1"># let&#39;s try that.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">deprecation_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start_casted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_slice_bound</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">start_casted</span> <span class="o">&lt;=</span> <span class="bp">self</span>
                    <span class="n">deprecation_mask</span> <span class="o">=</span> <span class="n">start_casted</span> <span class="o">==</span> <span class="bp">self</span>

                <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">end_casted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_slice_bound</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">end_casted</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
                    <span class="n">deprecation_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_casted</span> <span class="o">==</span> <span class="bp">self</span><span class="p">)</span> <span class="o">|</span> <span class="n">deprecation_mask</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">deprecation_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Value based partial slicing on non-monotonic DatetimeIndexes &quot;</span>
                        <span class="s2">&quot;with non-existing keys is deprecated and will raise a &quot;</span>
                        <span class="s2">&quot;KeyError in a future Version.&quot;</span><span class="p">,</span>
                        <span class="ne">FutureWarning</span><span class="p">,</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][::</span><span class="n">step</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indexer</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inferred_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># b/c datetime is represented as microseconds since the epoch, make</span>
        <span class="c1"># sure we can&#39;t have ambiguous indexing</span>
        <span class="k">return</span> <span class="s2">&quot;datetime64&quot;</span>

    <span class="k">def</span> <span class="nf">indexer_at_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index locations of values at particular time of day</span>
<span class="sd">        (e.g. 9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : datetime.time or str</span>
<span class="sd">            Time passed in either as object (datetime.time) or as string in</span>
<span class="sd">            appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;, &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;,</span>
<span class="sd">            &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;, &quot;%I%M%S%p&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_at_time : array of integers</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        indexer_between_time : Get index locations of values between particular</span>
<span class="sd">            times of day.</span>
<span class="sd">        DataFrame.at_time : Select values at particular time of day.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">asof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;asof&#39; argument is not supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">dateutil.parser</span> <span class="kn">import</span> <span class="n">parse</span>

            <span class="n">time</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index must be timezone aware.&quot;</span><span class="p">)</span>
            <span class="n">time_micros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">)</span><span class="o">.</span><span class="n">_get_time_micros</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_micros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_micros</span><span class="p">()</span>
        <span class="n">micros</span> <span class="o">=</span> <span class="n">_time_to_micros</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">micros</span> <span class="o">==</span> <span class="n">time_micros</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">indexer_between_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_end</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index locations of values between particular times of day</span>
<span class="sd">        (e.g., 9:00-9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time, end_time : datetime.time, str</span>
<span class="sd">            Time passed either as object (datetime.time) or as string in</span>
<span class="sd">            appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;, &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;,</span>
<span class="sd">            &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;,&quot;%I%M%S%p&quot;).</span>
<span class="sd">        include_start : bool, default True</span>
<span class="sd">        include_end : bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_between_time : array of integers</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        indexer_at_time : Get index locations of values at particular time of day.</span>
<span class="sd">        DataFrame.between_time : Select values between particular times of day.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">to_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">to_time</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
        <span class="n">time_micros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_micros</span><span class="p">()</span>
        <span class="n">start_micros</span> <span class="o">=</span> <span class="n">_time_to_micros</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
        <span class="n">end_micros</span> <span class="o">=</span> <span class="n">_time_to_micros</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_start</span> <span class="ow">and</span> <span class="n">include_end</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
        <span class="k">elif</span> <span class="n">include_start</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
            <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>
        <span class="k">elif</span> <span class="n">include_end</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>
            <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>

        <span class="k">if</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="n">join_op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">join_op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">join_op</span><span class="p">(</span><span class="n">lop</span><span class="p">(</span><span class="n">start_micros</span><span class="p">,</span> <span class="n">time_micros</span><span class="p">),</span> <span class="n">rop</span><span class="p">(</span><span class="n">time_micros</span><span class="p">,</span> <span class="n">end_micros</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">date_range</span><span class="p">(</span>
    <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a fixed frequency DatetimeIndex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : str or datetime-like, optional</span>
<span class="sd">        Left bound for generating dates.</span>
<span class="sd">    end : str or datetime-like, optional</span>
<span class="sd">        Right bound for generating dates.</span>
<span class="sd">    periods : int, optional</span>
<span class="sd">        Number of periods to generate.</span>
<span class="sd">    freq : str or DateOffset, default &#39;D&#39;</span>
<span class="sd">        Frequency strings can have multiples, e.g. &#39;5H&#39;. See</span>
<span class="sd">        :ref:`here &lt;timeseries.offset_aliases&gt;` for a list of</span>
<span class="sd">        frequency aliases.</span>
<span class="sd">    tz : str or tzinfo, optional</span>
<span class="sd">        Time zone name for returning localized DatetimeIndex, for example</span>
<span class="sd">        &#39;Asia/Hong_Kong&#39;. By default, the resulting DatetimeIndex is</span>
<span class="sd">        timezone-naive.</span>
<span class="sd">    normalize : bool, default False</span>
<span class="sd">        Normalize start/end dates to midnight before generating date range.</span>
<span class="sd">    name : str, default None</span>
<span class="sd">        Name of the resulting DatetimeIndex.</span>
<span class="sd">    closed : {None, &#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">        Make the interval closed with respect to the given frequency to</span>
<span class="sd">        the &#39;left&#39;, &#39;right&#39;, or both sides (None, the default).</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For compatibility. Has no effect on the result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rng : DatetimeIndex</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DatetimeIndex : An immutable container for datetimes.</span>
<span class="sd">    timedelta_range : Return a fixed frequency TimedeltaIndex.</span>
<span class="sd">    period_range : Return a fixed frequency PeriodIndex.</span>
<span class="sd">    interval_range : Return a fixed frequency IntervalIndex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,</span>
<span class="sd">    exactly three must be specified. If ``freq`` is omitted, the resulting</span>
<span class="sd">    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between</span>
<span class="sd">    ``start`` and ``end`` (closed on both sides).</span>

<span class="sd">    To learn more about the frequency strings, please see `this link</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Specifying the values**</span>

<span class="sd">    The next four examples generate the same `DatetimeIndex`, but vary</span>
<span class="sd">    the combination of `start`, `end` and `periods`.</span>

<span class="sd">    Specify `start` and `end`, with the default daily frequency.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,</span>
<span class="sd">                   &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Specify `start` and `periods`, the number of periods (days).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=8)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,</span>
<span class="sd">                   &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Specify `end` and `periods`, the number of periods (days).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(end=&#39;1/1/2018&#39;, periods=8)</span>
<span class="sd">    DatetimeIndex([&#39;2017-12-25&#39;, &#39;2017-12-26&#39;, &#39;2017-12-27&#39;, &#39;2017-12-28&#39;,</span>
<span class="sd">                   &#39;2017-12-29&#39;, &#39;2017-12-30&#39;, &#39;2017-12-31&#39;, &#39;2018-01-01&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Specify `start`, `end`, and `periods`; the frequency is generated</span>
<span class="sd">    automatically (linearly spaced).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-27&#39;, periods=3)</span>
<span class="sd">    DatetimeIndex([&#39;2018-04-24 00:00:00&#39;, &#39;2018-04-25 12:00:00&#39;,</span>
<span class="sd">                   &#39;2018-04-27 00:00:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">    **Other Parameters**</span>

<span class="sd">    Changed the `freq` (frequency) to ``&#39;M&#39;`` (month end frequency).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;M&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;, &#39;2018-04-30&#39;,</span>
<span class="sd">                   &#39;2018-05-31&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</span>

<span class="sd">    Multiples are allowed</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;3M&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,</span>
<span class="sd">                   &#39;2019-01-31&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)</span>

<span class="sd">    `freq` can also be specified as an Offset object.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=pd.offsets.MonthEnd(3))</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,</span>
<span class="sd">                   &#39;2019-01-31&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)</span>

<span class="sd">    Specify `tz` to set the timezone.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01 00:00:00+09:00&#39;, &#39;2018-01-02 00:00:00+09:00&#39;,</span>
<span class="sd">                   &#39;2018-01-03 00:00:00+09:00&#39;, &#39;2018-01-04 00:00:00+09:00&#39;,</span>
<span class="sd">                   &#39;2018-01-05 00:00:00+09:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns, Asia/Tokyo]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    `closed` controls whether to include `start` and `end` that are on the</span>
<span class="sd">    boundary. The default includes boundary points on either end.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2017-01-01&#39;, end=&#39;2017-01-04&#39;, closed=None)</span>
<span class="sd">    DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Use ``closed=&#39;left&#39;`` to exclude `end` if it falls on the boundary.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2017-01-01&#39;, end=&#39;2017-01-04&#39;, closed=&#39;left&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Use ``closed=&#39;right&#39;`` to exclude `start` if it falls on the boundary.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2017-01-01&#39;, end=&#39;2017-01-04&#39;, closed=&#39;right&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">com</span><span class="o">.</span><span class="n">any_none</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span>

    <span class="n">dtarr</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_generate_range</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dtarr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bdate_range</span><span class="p">(</span>
    <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span>
    <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weekmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">holidays</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a fixed frequency DatetimeIndex, with business day as the default</span>
<span class="sd">    frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : str or datetime-like, default None</span>
<span class="sd">        Left bound for generating dates.</span>
<span class="sd">    end : str or datetime-like, default None</span>
<span class="sd">        Right bound for generating dates.</span>
<span class="sd">    periods : int, default None</span>
<span class="sd">        Number of periods to generate.</span>
<span class="sd">    freq : str or DateOffset, default &#39;B&#39; (business daily)</span>
<span class="sd">        Frequency strings can have multiples, e.g. &#39;5H&#39;.</span>
<span class="sd">    tz : str or None</span>
<span class="sd">        Time zone name for returning localized DatetimeIndex, for example</span>
<span class="sd">        Asia/Beijing.</span>
<span class="sd">    normalize : bool, default False</span>
<span class="sd">        Normalize start/end dates to midnight before generating date range.</span>
<span class="sd">    name : str, default None</span>
<span class="sd">        Name of the resulting DatetimeIndex.</span>
<span class="sd">    weekmask : str or None, default None</span>
<span class="sd">        Weekmask of valid business days, passed to ``numpy.busdaycalendar``,</span>
<span class="sd">        only used when custom frequency strings are passed.  The default</span>
<span class="sd">        value None is equivalent to &#39;Mon Tue Wed Thu Fri&#39;.</span>
<span class="sd">    holidays : list-like or None, default None</span>
<span class="sd">        Dates to exclude from the set of valid business days, passed to</span>
<span class="sd">        ``numpy.busdaycalendar``, only used when custom frequency strings</span>
<span class="sd">        are passed.</span>
<span class="sd">    closed : str, default None</span>
<span class="sd">        Make the interval closed with respect to the given frequency to</span>
<span class="sd">        the &#39;left&#39;, &#39;right&#39;, or both sides (None).</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For compatibility. Has no effect on the result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DatetimeIndex</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``,</span>
<span class="sd">    exactly three must be specified.  Specifying ``freq`` is a requirement</span>
<span class="sd">    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not</span>
<span class="sd">    desired.</span>

<span class="sd">    To learn more about the frequency strings, please see `this link</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Note how the two weekend days are skipped in the result.</span>

<span class="sd">    &gt;&gt;&gt; pd.bdate_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,</span>
<span class="sd">               &#39;2018-01-05&#39;, &#39;2018-01-08&#39;],</span>
<span class="sd">              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;freq must be specified for bdate_range; use date_range instead&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">freq</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">weekmask</span> <span class="o">=</span> <span class="n">weekmask</span> <span class="ow">or</span> <span class="s2">&quot;Mon Tue Wed Thu Fri&quot;</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">prefix_mapping</span><span class="p">[</span><span class="n">freq</span><span class="p">](</span><span class="n">holidays</span><span class="o">=</span><span class="n">holidays</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="n">weekmask</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;invalid custom frequency string: </span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">elif</span> <span class="n">holidays</span> <span class="ow">or</span> <span class="n">weekmask</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;a custom frequency string is required when holidays or &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;weekmask are passed, got frequency </span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">date_range</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_time_to_micros</span><span class="p">(</span><span class="n">time_obj</span><span class="p">:</span> <span class="n">time</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">seconds</span> <span class="o">=</span> <span class="n">time_obj</span><span class="o">.</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">time_obj</span><span class="o">.</span><span class="n">minute</span> <span class="o">+</span> <span class="n">time_obj</span><span class="o">.</span><span class="n">second</span>
    <span class="k">return</span> <span class="mi">1_000_000</span> <span class="o">*</span> <span class="n">seconds</span> <span class="o">+</span> <span class="n">time_obj</span><span class="o">.</span><span class="n">microsecond</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Horst Duchene.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>